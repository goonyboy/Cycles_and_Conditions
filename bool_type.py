# Неявное приведение к булеву типу.
#   Если вы не используете никакой логический оператор или оператор сравнения в условном
# операторе, то интерпретатор за вас производит неявное приведение типов. То есть переводит
# переменную к bool и проверяет её значение. Вот сводная таблица приведения некоторых типов
# данных к bool:


#                               True                                    False

# int           (любое число, отличное от нуля)                         0
# float         (любое число с плавающей запятой, отличное от нуля)     0.0
# str           (любая непустая строка)                                 ''
# list          (любой непустой список)                                 []
# dict          (любой непустой словарь)                                {}
# NoneType      —                                                       None

print(bool(0))      # False
print(bool(1))      # True

print(bool([1]))    #True
print(bool([]))     #False

print(bool('A'))    # True
print(bool(''))     # False

# 1
# Рассмотрим парочку примеров. Если ваша задача проверить, можно ли делить,
# и является ли делитель нулем, то проверку в явном виде zero != 0 делать излишне.

zero = 0
if zero:
   print(10 / zero)
else:
   print("Делить на ноль нельзя")

# 2
# Если вам нужно проверить, пустая строка или нет, то сравнивать её таким способом
# password == "", а уж тем более таким len(password) == 0 ни к чему.

password = ''
if not password:
   print('Вы забыли ввести пароль')
else:
   print('Пароль введен')

